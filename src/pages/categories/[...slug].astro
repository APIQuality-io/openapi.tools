---
import type { GetStaticPaths } from 'astro';
import { getCollection } from 'astro:content';

import PageHeader from '@/components/PageHeader.astro';
import Layout from '../../layouts/Layout.astro';

// 1. Generate a new path for every collection entry
export const getStaticPaths: GetStaticPaths = async () => {
  const categories = await getCollection('categories');
  return categories.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
};

// 2. For your template, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();

// 3 get entries for this category from the Tools collection
const allTools = await getCollection('tools');

const tools = allTools
  .filter((tool) => {
    if (!tool.data.categories) {
      return false;
    }
    const categories = tool.data.categories;
    // look through the categories list to see if any of the categories matches enry.slug
    return categories.some((category) => category.slug === entry.slug);
  })
  .sort((a, b) => {
    const checkIsCurrentSponsor = (currentTool: (typeof allTools)[0]) => {
      if (!currentTool.data.sponsorship) {
        return false;
      }
      if (
        !currentTool.data.sponsorship.startDate ||
        !currentTool.data.sponsorship.endDate
      ) {
        return false;
      }
      const startDate = new Date(currentTool.data.sponsorship.startDate);
      const endDate = new Date(currentTool.data.sponsorship.endDate);
      const now = new Date();
      return startDate < now && endDate > now;
    };

    // sponsored tools come first, with the sponsor that started the earliest coming first
    // then sort by name
    const aSponsor = checkIsCurrentSponsor(a);
    const bSponsor = checkIsCurrentSponsor(b);

    if (aSponsor && !bSponsor) {
      return -1;
    }
    if (!aSponsor && bSponsor) {
      return 1;
    }

    const bDate = b.data.sponsorship?.startDate;
    const aDate = a.data.sponsorship?.startDate;
    // both are sponsored, sort by start date
    // note: gross syntax here because TypeScript is not happy with the optional chaining
    if (aSponsor && bSponsor && aDate !== undefined && bDate !== undefined) {
      return new Date(aDate).getTime() - new Date(bDate).getTime();
    }

    return a.data.name.localeCompare(b.data.name);
  });

const toolCount = tools.length;
---

<Layout title={entry.data.name}>
  <PageHeader title={entry.data.name} description={entry.data.description}>
    {/* render the body of the markdown file for this category */}
    <div
      class="prose prose-lg dark:prose-invert prose-headings:text-slate-700/90 dark:prose-headings:text-slate-300/90"
    >
      <Content />
    </div>
  </PageHeader>

  <hr class="my-6" />

  <main class="prose prose-lg dark:prose-invert">
    <h2 class="mb-4 text-2xl font-bold">{toolCount} {entry.data.name}</h2>
    <section class="flex flex-col gap-4">
      {
        tools.map((tool) => {
          return (
            <div>
              {tool.data.sponsorship && tool.data.sponsorship.startDate && (
                <div>
                  <span class="text-sm font-semibold">Sponsored</span>
                </div>
              )}
              {tool.data.name}
              {tool.data.description}
              {tool.data?.languages && (
                <span>languages</span>
                <pre>
                  {JSON.stringify(tool.data?.languages, null, 2)}
                </pre>
              )}
            </div>
          );
        })
      }
    </section>
  </main>
</Layout>
